---
title: "Correlation and Association"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, comment='', message = FALSE, error = TRUE, warning=FALSE, fig.width=8)
```


```{r}
# Get data
df <- params$data
df2 <- df
df <- df[,params$vars1,drop=FALSE]
```

```{r}
# Call used libraries 
library(knitr) # kable
library(fastDummies) # make dummies
library(lavaan)
library(semPlot)
library(corrplot)

eval <- FALSE
tryCatch({

# Drop columns if all observations are missing 
col_names_missing <- sapply(df, function(col) all(is.na(col)))
df[ ,col_names_missing] <- list(NULL)
df_list <- df 

# Drop empty rows
rowsums <- data.frame(sapply(df,is.na))
if (length(which(rowSums(rowsums) == dim(df)[2])) != 0L){
  rows_drop <- (which(rowSums(rowsums) == dim(df)[2]))
  length_non_complete <- length(which(rowSums(rowsums) == dim(df)[2]))
  df <- df[-rows_drop, ,drop=FALSE]
}

# Drop columns with one unique value (NAs not considered)
cols_one <- sapply(df, function(col) length(unique(na.omit(col))) == 1)
df[,cols_one] <- list(NULL)

# Drop character variables with more than 10 categories, NAs included 
cols_catlarge <- sapply(df, function(col) is.character(col) & length(unique(col)) >10)
df[,cols_catlarge] <- list(NULL)

# Convert logical variables to character
cols_logical <- sapply(df, function(col) is.logical(col))
df[ ,cols_logical] <- sapply(df[ ,cols_logical], as.character)

# Extract continuous and ordinal variables 
df_num <- df[which(sapply(df, is.numeric) == 1L)]
rateunique_df <- sapply(df_num, function(col) (length(unique(na.omit(col))) / length(na.omit(col))) >= cutoffcont(length(na.omit(col))))
cols_continuous <- names(which(rateunique_df == TRUE))
cols_ordinal <- names(which(rateunique_df == FALSE))

# Extract binary character variables 
cols_binary <- sapply(df, function(col) is.character(col) & length(unique(na.omit(col))) == 2)
cols_binary_names <- names(which(cols_binary == TRUE))
df_binary <- df[,cols_binary,drop=FALSE]

# Make dummy variables for the character variables with more than 2 levels 
cols_dummy <- sapply(df, function(col) is.character(col) & length(unique(na.omit(col))) > 2)
df_dummy <-  df[,cols_dummy,drop=FALSE]
if (ncol(df_dummy)>0) {
  dummies <- fastDummies::dummy_cols(df_dummy, remove_first_dummy = TRUE, ignore_na=TRUE)
  dummies2 <- dummies[,-cols_dummy,drop=FALSE]
  df_binary <- merge(df_binary,dummies2,by="row.names")
} 

# Put together 
df_work <- merge(df_num,df_binary,by="row.names")
df_work$Row.names <- NULL
df_work$Row.names.y <-NULL

# Initialize next computations
eval <- TRUE

}, error=function(e) {
  
  stop(safeError("Outputs cannot be generated. Please check your data for consistency."))
  
}

)

```


```{r, results="asis", eval=eval}
# Chunk with first page of basic information

cat("\n# Basic Information", fill=TRUE)
cat("Automatic statistics for the file:", fill=TRUE)
dataname <- params$filename[1]
kable(dataname, col.names = "File")

cat("Your selection for the encoding:", fill=TRUE)
if (params$fencoding=="unknown"){
  cat("Auto")
} else {cat("UTF-8")}
cat("\\newline",fill=TRUE) 

cat("Your selection for the decimal character:", fill=TRUE)
if (params$decimal=="auto"){
  cat("Auto")
} else {cat(params$decimal)}
cat("\\newline",fill=TRUE) 
  
cat("Observations (rows with at least one non-missing value): ", fill=TRUE)
cat(dim(df)[1])
cat("\\newline",fill=TRUE) 

# Missing rows
if (exists("length_non_complete")){
  cat("Number of rows that are dropped because they contain no values (all values are missing):", length_non_complete)
  cat("\\newline",fill=TRUE) 
}

cat("Variables (columns with at least one non-missing value): ", fill=TRUE)
cat(dim(df_list)[2])
cat("\\newline",fill=TRUE) 

cat("Variables considered continuous: ", fill=TRUE)
if (exists("df_num")){
  if (ncol(df_num)>0){
    if (sum(rateunique_df )>0){
      cat(sum(rateunique_df==TRUE),fill=TRUE)
      kable(cols_continuous, col.names = "Variables considered continuous")
    }
  } else {
    
    cat("0",fill=TRUE)
    cat("\\newline",fill=TRUE) }
}


cat("Numerical variables considered binary or ordinal: ", fill=TRUE)
if (exists("df_num")){
  if (ncol(df_num)>0){
    if (sum(rateunique_df==FALSE)>0){
      cat(sum(rateunique_df==FALSE),fill=TRUE)
      kable(cols_ordinal, col.names = "Numerical variables considered binary or ordinal")
    } else {
    
    cat("0",fill=TRUE)
    cat("\\newline",fill=TRUE) }
}}


cat("Character variables considered binary: ", fill=TRUE)
if (exists("cols_binary")){
  if (sum(cols_binary)>0){
    cat(sum(cols_binary),fill=TRUE)
    kable(names(which(cols_binary==TRUE)), col.names = "Character variables considered binary")
  } else {
    cat("0",fill=TRUE)
    cat("\\newline",fill=TRUE) }
}


cat("Character variables considered norminal and transformed to binary: ", fill=TRUE)
if (exists("cols_dummy")){
  if (sum(cols_dummy)>0){
    cat(sum(cols_dummy),fill=TRUE)
    kable(colnames(dummies2), col.names = "Binary dummies for nominal variables")
  } else {
    cat("0",fill=TRUE)
    cat("\\newline",fill=TRUE) }
}


# Char with just one unique value not considered
if (exists("cols_one")){
  if (sum(cols_one) != 0L){
    cat("Columns with just one unique value (missings omitted) which are not considered in further computations: ")
    cat(sum(cols_one) ,fill=TRUE)
    cols <- names(which(cols_one==1))
    kable(cols, col.names = "Columns not considered")
  }
}

# Char > 10 not considered
if (exists("cols_catlarge")){
  if (sum(cols_catlarge) != 0L){
    cat("Character columns with more than 10 unique values which are not considered in further computations: ")
    cat(sum(cols_catlarge),fill=TRUE)
    cols <- names(which(cols_catlarge==1))
    kable(cols, col.names = "Columns not considered")
  }
}


# Missing columns
if (exists("col_names_missing")){
  if (sum(col_names_missing) != 0L){
    cat("\n\n\\small Number of columns that are dropped because they contain no values (all values are missing):", sum(col_names_missing))
    cat("\\newline",fill=TRUE) 
  } 
}

# Missings more than 50%
complete_rate <- sapply(df_work, function(col) 1-(sum(is.na(col)) / dim(df)[1])) 
if (length(which(complete_rate < 0.5)) != 0L){
  cat("**Warning: These variables have more than 50% missing values:**")
  miss_var <- names(which(complete_rate < 0.5)) 
  kable(miss_var, col.names = "Variable")
}


# Numeric falsly to char? 
check_reading <- function(col){
  numeric <- !is.na(as.numeric(col))
  return(sum(numeric)/sum(!is.na(col)))
}
numeric_percent <- sapply(df_dummy, function(col) check_reading(col))

if (length(numeric_percent[(numeric_percent>0.9)]) != 0L){
  cat("**Warning: More than 90% of the values of these columns could be treated as numeric. Nevertheless, because of some values or the selected decimal character, the columns must be treated as discrete. Are all the values plausible? Please check your data once more before uploading! Column(s):**", names(numeric_percent[(numeric_percent>0.9)]),fill=TRUE)
}
```

\pagebreak

```{r, results="asis", dev="cairo_pdf", eval=eval}

# Initialize next computations
eval2 <- FALSE

tryCatch({
  
  fit <- cfa(params$model, data=df_work, missing="fiml", estimator="ML") 
  pe <- parameterEstimates(fit, standardized=TRUE)
  stdload <- pe[which(pe$op=="=~"),"std.all"]
  nfac <- fit@pta$nfac[[1]]
  eval2 <- TRUE

}, error=function(e) {
  
  stop(safeError("Errors in the cfa execution. Please reconsider your data or your model."))
  
}

)
```     

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n# Model Syntax", fill=TRUE)
info <- inspect(fit, what="list")
info <- info[,c(2,3,4,5,8)]
cat("The following table describes the applied model equations in lavaan model syntax, either as entered by you in the text area (denoted by User=1) or established internally (User=0). The last column numbers the free parameters which are estimated.")
kable(info, col.names=c("Left hand side","Operator","Right hand side","User","Free parameter"))
```               

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n# Assumptions", fill=TRUE)
cat("bla", fill=TRUE)
```           

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n# Model Settings", fill=TRUE)
cat("bla", fill=TRUE)
```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n# Lavaan Outputs", fill=TRUE)
cat("\n## Model Summary", fill=TRUE)
```

```{r, dev="cairo_pdf", eval=eval2}

eval3<- FALSE
tryCatch({
  
  summary(fit, standardized=TRUE, fit.measures=TRUE)
  eval3 <- TRUE
  
}, error=function(e) {
  
  stop(safeError("The summary statistics of the CFA cannot be computed error-free. Please reconsider your data or your model."))
  
}

)

```


```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n# Interpretation", fill=TRUE)
cat("\n## Overall Goodness of Fit", fill=TRUE)
cat("We consider fit indices from the Model Summary to check the overall goodness of fit. Values from the Model Summary are rounded where appropiately. ", fill=TRUE)
```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**Model Test User Model**", fill=TRUE)
cat("\\newline",fill=TRUE) 

# Saturated vs non-saturated model 

# Number of in the model used indicator variables
vars <- fit@pta$nvar[[1]]

# Number of knowns
knowns <- (vars*(vars+1))/2+vars # If FIML used 

if (fit@Fit@test$standard$df>0){
  cat("The degrees of freedom (df) are", fit@Fit@test$standard$df, "and positive, indicating an over-identified model, fact which basically enables further analysis and interpretation. ")
  dfindic <- TRUE
} else if (fit@Fit@test$standard$df==0){
   cat("The degrees of freedom (df) are", fit@Fit@test$standard$df, ", indicating a just-identified or saturated model. ")
} else {
  cat("The degrees of freedom (df)", fit@Fit@test$standard$df, "are negative, indicating an under-identified model, fact which basically disables further analysis and interpretation. ")
}

cat("Comment: The df are calculated as the number of known parameters minus the number of free parameters: ",knowns,"-",fit@Fit@npar,"=",fit@Fit@test$standard$df,". ")

eval3 <- (eval2 && dfindic)
    
```

```{r, results="asis", dev="cairo_pdf", eval=eval3}
########
### Chi2
########

cat("The test statistic with the value ",round(fit@Fit@test$standard$stat,3),"is the chi-square model fit index, representing the difference between summaries of the model-implied covariance matrix and the observed covariance matrix. It is a so called absolute fit index, evaluating the reasonability of the model at an absolute level (e.g. Brown). ")

cat("The p-value of the test of a zero difference is ", pformat(fit@Fit@test$standard$pvalue))

if (fit@Fit@test$standard$pvalue > 0.05){
  cat(". Therefore, the chi-square test of model fit is not statistically significant at 5% type I error")
 
  if (weightchi2(nrow(df_work),nfac,max(stdload)) %in% c(0.5,1)){
    cat(", suggesting an acceptable model fit. Considering also other relevant characteristics of the data resp. the model (sample size, number of factors, estimated loadings), we assume a reliable chi-square model fit index and include this result in the overall evaluation of the goodness-of-fit.  ")
  } else {
  cat(". But considering also other relevant characteristics of the data resp. the model (sample size, number of factors, estimated loadings), we do not assume a reliable chi-square model fit index and do not further interpret this result. ")
}
  
} else {
  cat(". Therefore, the chi-square test of model fit is statistically significant at 5% type I error") 
  
  if (weightchi2(nrow(df_work),nfac,max(stdload)) %in% c(0.5,1)){
    cat(", suggesting a non-acceptable model fit. Considering also other relevant characteristics of the data resp. the model (sample size, number of factors, estimated loadings), we assume a reliable chi-square model fit index and include this result in the overall evaluation of the goodness-of-fit.  ")
  } else {
  cat(". But considering also other relevant characteristics of the data resp. the model (sample size, number of factors, estimated loadings), we do not assume a reliable chi-square model fit index and do not further interpret this result. ")
}
  
}


chi2 <- (fit@Fit@test$standard$pvalue > 0.05)
chi2_weight<- weightchi2(nrow(df_work),nfac,max(stdload))

```

```{r, results="asis", dev="cairo_pdf", eval=eval3}
#########
# Chitodf
#########

if ((max(stdload)<=0.5) || (max(stdload)<=0.6 && nfac>=8)){

  cat("Directly related is the chi-square to the degrees of freedom ratio: ", fit@Fit@test$standard$stat,"/",fit@Fit@test$standard$df,"=",round(fit@Fit@test$standard$stat/fit@Fit@test$standard$df,3))
    
  if  (round(fit@Fit@test$standard$stat/fit@Fit@test$standard$df,3) < 2){
    cat(". This ratio is smaller than the threshold value 2, suggesting an acceptable model fit. ")
    
  } else {
    cat(". This ratio is greater or equal than the threshold value 2, suggesting a questionable or non-acceptable model fit. ") 
  }
}  

chi2todf <- (round(fit@Fit@test$standard$stat/fit@Fit@test$standard$df,3) < 2) 
chi2todf_weight <- ((max(stdload)<=0.5) || (max(stdload)<=0.6 && nfac>=8))*1L
```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**Model Test Baseline Model**", fill=TRUE)
cat("\\newline",fill=TRUE)
cat(" The test statistic with the value ",round(fit@baseline$test$standard$stat,3), " represents the difference between summaries of another model-implied covariance matrix with zero covariances (a baseline model assuming independent variables, i.e. a worst fitting model) and the observed covariance matrix. It is used only indirectly in a model fit index and not further commented here. ", fill=TRUE)
```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**User Model versus Baseline Model**", fill=TRUE)
cat("\\newline",fill=TRUE)
cat(" The Comparative Fit Index (CFI),  evaluates the fit of the your model in relation to the worst-fitting baseline model (which assumes independent variables) and ranges between zero and one. ", fill=TRUE)

if (round(fitMeasures(fit)["cfi"],2)>=0.9){
  cat("Your CFI value of ",round(fitMeasures(fit)["cfi"],2),"is greater or equal than 0.90, suggesting an acceptable model fit. ")
} else if (round(fitMeasures(fit)["cfi"],2)>=0.95) {
  cat("Your CFI value of ",round(fitMeasures(fit)["cfi"],2),"is greater or equal than 0.95, suggesting a good model fit. ")
} else {
  cat("Your CFI value of ",round(fitMeasures(fit)["cfi"],2),"is smaller or equal than 0.90, suggesting a non-acceptable model fit. ")
}

cfi <- (round(fitMeasures(fit)["cfi"],2)>=0.9)
cfi_weight <- 1L

```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("The Tucker-Lewis Index (TLI), evaluates the fit of the your model in relation to the worst-fitting baseline model (which assumes independent variables). Overly complex models are penalized. Values can by any real numbers. ", fill=TRUE)

if (round(fitMeasures(fit)["tli"],2)>=0.9){
  cat("Your TLI value of ",round(fitMeasures(fit)["tli"],2),"is greater or equal than 0.90, suggesting an acceptable model fit. ")
} else if (round(fitMeasures(fit)["tli"],2)>=0.95) {
  cat("Your TLI value of ",round(fitMeasures(fit)["tli"],2),"is greater or equal than 0.95, suggesting a good model fit. ")
} else {
  cat("Your TLI value of ",round(fitMeasures(fit)["tli"],2),"is smaller or equal than 0.90, suggesting a non-acceptable model fit. ")
}

tli <- (round(fitMeasures(fit)["tli"],2)>=0.9)
tli_weight <- 1

```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**Root Mean Square Error of Approximation:**", fill=TRUE)
cat("\\newline",fill=TRUE)
cat("The Root Mean Square Error of Approximation (RMSEA) is a parsimony correction fit index based on the chi-square absolute model fit index. Overly complex models are penalized. Values can be greater or equal than zero, with values close to zero suggesting an acceptable model fit. ", fill=TRUE)

if (round(fitMeasures(fit)["rmsea"],2)<0.08){
  cat("The RMSEA: ",round(fitMeasures(fit)["rmsea"],2),"is smaller than the threshold value 0.08, suggesting an acceptable model fit. ")
} else {
   cat("The RMSEA: ",round(fitMeasures(fit)["rmsea"],2),"is greater or equal than the threshold value 0.08, suggesting a non-acceptable model fit. ")
}

# Consider weight based on Beauducel 2005
rmsea <- (round(fitMeasures(fit)["rmsea"],2)<0.08)
rmsea_weight <- 1-0.5*(nfac<=4 && max(stdload)>0.6)

cat("\\newline",fill=TRUE)

if (fitMeasures(fit)["rmsea.pvalue"]>0.05){
  cat("The p-value of close fit ",pformat(fitMeasures(fit)["rmsea.pvalue"]),"suggests that the RMSEA is not statistically significant larger than 0.05, suggesting an acceptable model fit. ")
} else {
  cat("The p-value of close fit ",pformat(fitMeasures(fit)["rmsea.pvalue"]),"suggests that the RMSEA is statistically significant larger than 0.05, suggesting a non-acceptable model fit. ")
}

rmseap <- (fitMeasures(fit)["rmsea.pvalue"]>0.05)

```


```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**Standardized Root Mean Square Residual:**", fill=TRUE)
cat("\\newline",fill=TRUE)
cat("The Standardized Root Mean Square Residual (SRMR) is an absolute model fit index derived from the residual correlation matrix with a range between zero and one with values close to zero suggesting an acceptable model fit. ", fill=TRUE)

cat("\\newline",fill=TRUE)

if (round(fitMeasures(fit)["srmr"],2)<0.08){
   cat("The SRMR value of ",round(fitMeasures(fit)["srmr"],3),"is smaller than the threshold value 0.08, suggesting an acceptable model. ")
} else {
   cat("The SRMR value of ",round(fitMeasures(fit)["srmr"],2),"is greater or equal than the threshold value 0.08, suggesting a non-acceptable model. ")
}

srmr <- (round(fitMeasures(fit)["srmr"],2)<0.08)
srmr_weight <- 1-0.5*(nfac<=4 && max(stdload)>0.6)

```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**Our Overall Interpretation:**", fill=TRUE)
cat("\\newline",fill=TRUE)  
cat("In the overall interpretation of the fit indices, we consider also additionally aspects of the data resp. the model, e.g. the sample size, the number of factors or the magnitude of the loadings. We summarize the results and add a performance weight of the fit indices, based on results from Beauducel & Wittmann [@beauducel]:")

if ((max(stdload)<=0.5) || (max(stdload)<=0.6 && nfac>=8)){
  gof <- c(chi2,chi2todf,cfi,tli,rmsea,rmseap,srmr)
  gof_weight <- c(chi2_weight,chi2todf_weight,cfi_weight,tli_weight,rmsea_weight,NA,srmr_weight)
  gof_names <- c("Chi2 p-value","Chi2toDF","CFI","TLI","RMSEA","RMSEA p-value","SRMR")
  gof_df <- data.frame(gof,gof_weight,row.names=gof_names)
  gof_df2 <- gof_df[,-c(6)]
} else {
  gof <- c(chi2,cfi,tli,rmsea,rmseap,srmr)
  gof_weight <- c(chi2_weight,cfi_weight,tli_weight,rmsea_weight,NA,srmr_weight)
  gof_names <- c("Chi2 p-value","CFI","TLI","RMSEA","RMSEA p-value","SRMR")
  gof_df <- data.frame(gof,gof_weight,row.names=gof_names)
  gof_df2 <- gof_df[,-c(5)]
}

options(knitr.kable.NA = '')
kable(gof_df, col.names=c("Goodness of Fit","Weight"))

interpret(gof_df2)

```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n## Localized Area of Strain", fill=TRUE)
cat("In the next step, we investigate the residuals and the modification indices, which  are \"frequently used to identify focal areas of misfit in CFA solution\" [@cfa]. ", fill=TRUE)
```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("**Residuals:**", fill=TRUE)
cat("We consider in what follows: ", fill=TRUE)
```

```{r, results="asis", dev="cairo_pdf", eval=eval2}
# Covariance matrix
# inspect(fit, "sampstat")$cov  # Observed cov 
# inspect(fit, what="cov.ov") # Fitted cov
covraw <- resid(fit, type="raw")$cov # Residuals on cov
cat("Vizualization of the residual covariance matrix")
corrplot::corrplot(covraw, is.corr = FALSE,
               type = 'lower',
               order = "original",
               tl.col='black', tl.cex=.75, number.cex=0.75, method="number")

covstd <-resid(fit, type="standardized")$cov # Std residuals on cov
cat("Vizualization of the standardized residual matrix")
corrplot::corrplot(covstd, is.corr = FALSE,
               type = 'lower',
               order = "original",
               tl.col='black', tl.cex=.75, number.cex=0.75, method="number")


# Correlation matrix
# inspect(fit, what="cor.ov") # Fitted corr
# lavCor(fit) # Observed cor
r <- resid(fit, "cor")$cov # Residuals on cor
cat("Vizualization of the residual correlation matrix")
corrplot::corrplot(r, is.corr = FALSE,
               type = 'lower',
               order = "original",
               tl.col='black', tl.cex=.75, number.cex=0.75, method="number")
```  

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n## Parameter Estimates", fill=TRUE)
```  

```{r, dev="cairo_pdf", eval=eval2}
standardizedSolution(fit, type="std.all")
```  

```{r, results="asis", dev="cairo_pdf", eval=eval2}
cat("\n## Path Diagram", fill=TRUE)
semPaths(fit)
```    
     
```{r, results="asis", eval=eval2}

tryCatch({

# Title 
cat("\n# R Statistical Methods", fill=TRUE)
cat("The statistical analysis was done using R [@stats]. ", fill=TRUE)
cat("In our interpretation, we will use the term *variables* instead of *indicators* or *items*. ")
cat("\\newline",fill=TRUE)    
    
    
}, error=function(e) {cat("")}

)

```



